# 알고리즘 기초

미니 프로젝트가 끝나고 내가 부트캠프를 잘 끝낼 수 있을까 생각하다가 알고리즘을 시작하면서 본격적으로 주특기를 공부하기 전에 필수 지식인 Java를 공부하는 시간을 가질 수 있었다. 
단순히 강의를 듣고 따라하는 것이 아닌, 알고리즘 문제를 직접 풀어보며 내가 사용할 언어에 대해 더 잘 이해할 수 있습니다. 
실제로 미니 프로젝트를 하면서 언어에 기본적인 이해가 부족하여 어떻게 구동되는지 이 함수를 어떻게 쓰이는지에 대해 어려움이 있었다. 
하지만 알고리즘을 직접 풀어보면서 java에 대한 이해도를 높일 수 있었고 다양한 함수를 접하며 컴퓨터적 사고 능력을 기를 수 있었다.
알고리즘 기초 주차 이후 알고리즘을 풀어보며 알고리즘에 꼭 필요한 시간을 가지면서 코딩 테스트에 대비하고 있다.


# 알고리즘 공부

처음  알고리즘을 풀면서 어떻게 풀어야되는지 막막했다. 그때 항해99에서 제공해준 "별 찍기 예제로 알고리즘과 악수하기"를 통한 알고리즘 문제 푸는 방법이 도움이 많이 됐다. 
처음은 그냥 부딪쳐보자는 느낌으로 풀었는데 java의 이해도의 낮음도 문제지만 문제의 규칙을 찾는데 오랜시간이 걸렸다. 한동안 그냥 풀어보는 방식으로 풀며 끙끙되다가 근본적인 방식에
문제가 있다고 생각되어 문제풀이 방법을 사용해보았다.
풀이방식은 

1. 문제분석
    - 문제를 정확히 이해합니다.
    - 분석한 내용을 정리합니다.
2. 규칙찾기
    - 분석 내용을 바탕으로 규칙을 찾습니다.
3. 코딩화
    - 분석 내용을 바탕으로 알맞은 구현방법을 찾습니다.
4. 코딩
    - 실제로 코딩을 수행합니다.
    - 통과하지 못한다면 문제가 있는 순서(1 ~ 3번중)로 다시 돌아가서 진행합니다.
   
으로 굉장히 간단한 방법이다. 이러한 방법을 하나 안하나 별 상관없을 것이라 생각하고 하지않았으나 하고보니 꼭 필요한 방식임을 깨달았다. 
해당 방식을 진행하면서 규칙을 조금 더 손쉽게 찾을 수 있고 찾아낸 방식을 토대로 코딩화를 통해 구현방법을 찾아가며 사전지식을 학습하면서 풀 수 있었다. 
또한 점차적으로 컴퓨터적 사고 능력을 기를 수 있어던 것 같다.
그리고 알고리즘을 풀며 푼 내용을 [정리](https://github.com/asbazq/TIL/blob/8a76fa2fd06315238534d5dde70e88559e018b0c/algorithm/marathon.md)하는 것이 내가 무엇을 알고 무엇을 모르는지 알지 못하는지 알 수 있는 시간을 가졌던 것 같다. 
처음은 푼 알고리즘을 다시 적어보고 사용한 함수를 적는 형식으로 작성하였는데 나중에 다시 풀어볼 때 다시 적용하는데 어려움을 느꼇다. 
그래서 왜 이러한 함수를 사용했는지 왜 이렇게 적용했는지 주석을 통해 적어주었는데 이러한 방식이 내가 왜 이런생각을 하고 적용했는지 알 수 있어 좋았던 것 같다.

알고리즘을 풀 때 초반에는 함수를 사용하여 줄이며 푸는 게 좋은 줄 알았는데, 차후 풀어보면서 여러 방식을 생각해보고 다양하게 구현해보며 컴퓨터적 사고증진을 기르는 게 중요하다고 생가되어진다.

# 객체지향 프로그래밍(OOP)

프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법

- 장점
    - 코드 재사용이 용이 
        - 남이 만든 클래스를 가져와서 이용할 수 있고 상속을 통해 확장해서 사용할 수 있다.
    - 유지보수가 쉬움  
        - 수정해야 할 부분이 클래스 내부에 멤버 변수혹은 메서드로 존재하기 때문에 해당 부분만 수정하면 된다. 
    - 대형 프로젝트에 적합 
        - 클래스 단위로 모듈화시켜서 개발할 수 있으므로 대형 프로젝트처럼 여러 명, 여러 회사에서 프로젝트를 개발할 때 업무 분담하기 쉽다.
- 단점
    - 처리 속도가 상대적으로 느림
    - 객체가 많으면 용량이 커질 수 있음
    - 설계시 많은 시간과 노력이 필요

## 키워드 5가지

1) 클래스 + 인스턴스(객체)
2) 추상화
3) 캡슐화
4) 상속
5) 다형성

### 클래스 + 객체
 
클래스 : 어떤 문제를 해결하기 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 속성(attribute)과 행위(behavior)를 변수와 메서드로 정의한 것으로 객체를 만들기 위한 메타정보라고 볼 수 있다.
인스턴스(객체) : 클래스에서 정의한 것을 토대로 실제 메모리에 할당된 것으로 실제 프로그램에서 사용되는 데이터

### 추상화 (자료의 추상화)

객체 지향 프로그래밍에서는 '추상화' 라는 단어를 여러 군데 붙일 수 있다.
여기서 말하는 추상화는 추상 클래스나 추상 클래스가 갖는 추상 메서드를 의미하기보다는 클래스를 설계하는 것 자체를 의미한다.
즉, "공통의" 속성이나 기능을 묶어 이름을 붙이는 것이다.

### 캡슐화

변수와 함수를 하나의 단위로 묶는 것을 의미한다 즉, "클래스"라는 "캡슐"에 분류해서 넣는것이 캡슐화다.
 해당 클래스의 인스턴스 생성을 통해 클래스 안에 포함된 멤버 변수와 메소드에 쉽게 접근할 수 있다.
 
#### 캡슐화의 목적 2가지

1. 코드를 재수정 없이 재활용하는 것.
    - 캡슐화를 통해 객체가 외부에 노출하지 않아야할 정보 또는 기능을 접근제어자를 통해 적절히 제어 권한이 있는 객체에서만 접근하도록 할 수 있기에 코드의 수정이 일어났을 때 책임이 있는 객체만 수정하면 되기에 영향 범위를 예측하는데 수월해졌다.
2. 접근 제어자를 통한 정보 은닉
    - 뿐만 아니라 관련된 기능과 특성을 한 곳에 모으고 분류하기 때문에 객체 재활용이 원활해졌다.

### 상속

상속은 자식 클래스가 부모 클래스의 특성과 기능을 그대로 물려받는 것을 말한다. 기능의 일부분을 변경해야 할 경우 자식 클래스에서 상속받은 그 기능만을 수정해서 다시 정의하게 되는데, 이러한 작업을 '오버라이딩(overriding)'이라고 한다. 상속은 캡슐화를 유지하면서도 클래스의 재사용이 용이하도록 해 준다.
**다중상속은 불가** 

### 다형성

하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것이다.
즉 오버라이딩(Overriding), 오버로딩(Overloading)이 가능하다는 얘기다.
오버라이딩 : 부모클래스의 메서드와 같은 이름, 매개변수를 재정의 하는것.
오버로딩 : 같은 이름의 함수를 여러개 정의하고, 매개변수의 타입과 개수를 다르게 하여 매개변수에 따라 다르게 호출할 수 있게 하는 것.

> 번외) getter, setter 

멤버변수에 직접접근하지 못하게 private으로 접근지정자를 설정하고 public으로 getter, setter 메서드를 만드는 것을 많이 해왔다.
그러면서 이럴꺼면 어차피 아무나 접근가능한데 왜 private을 할까? 라고 생각했었다.
결론부터 말하면 getter, setter를 사용하면 메서드를 통해서 접근하기 때문에, 메서드 안에서 매개변수같이 어떤 올바르지 않은 입력에 대해 사전에 처리할 수 있게 제한하거나 조절할 수 있기 때문이다.
예를들면 setter에서 유효범위를 넘은 정수가 들어왔을 때의 처리를 하고나서 set하거나 예외처리를 해버릴 수 있는 것이다.
getter도 마찬가지로 굳이 예를들자면 자료에 무언가 더하거나 빼고 준다든지가 가능하다.

출처: https://jeong-pro.tistory.com/95 [기본기를 쌓는 정아마추어 코딩블로그:티스토리]

# JVM

Java Virtual Machine의 줄임말.
Java로 개발한 프로그램을 컴파일하여 만들어지는 바이트코드를 실행시키기 위한 가상머신

## JVM 구조

- 클래스 로더(Class Loader)
- 실행 엔진(Execution Engine)
    - 인터프리터(Interpreter)
    - JIT 컴파일러(Just-in-Time)
    - 가비지 콜렉터(Garbage collector)
- 런타임 데이터 영역 (Runtime Data Area)

* 클래스 로더

JVM 내로 클래스 파일(*.class)을 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈이다.
런 타임시 동적으로 클래스를 로드하고 jar 파일 내 저장된 클래스들을 JVM 위에 탑재한다.
즉, 클래스를 처음으로 참조할 때, 해당 클래스를 로드하고 링크한는 역할을 한다.

* 실행 엔진

클래스를 실행시키는 역할이다.
클래스 로더가 JVM내의 런타임 데이터 영역에 바이트 코드를 배치시키고, 이것은 실행 엔진에 의해 실행된다.
자바 바이트 코드(*.class)는 기계가 바로 수행할 수 있는 언어보다는 비교적 인간이 보기 편한 형태로 기술된 것이다. 그래서 실행 엔진은 이와 같은 바이트 코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경한다.

⊙ 인터프리터

실행 엔진은 자바 바이트 코드를 명령어 단위로 읽어서 실행한다.
하지만 한 줄씩 수행하기 때문에 느리다는 단점이 있다.

⊙ JIT(Just-In-Time)

인터프리터 방식으로 실행하다가 적절한 시점에 바이트 코드 전체를 컴파일하여 기계어로 변경하고, 이후에는 해당 더 이상 인터프리팅 하지 않고 기계어로 직접 실행하는 방식이다.

* 가비지 콜렉터

더이상 사용되지 않는 인스턴스를 찾아 메모리에서 삭제함.

출처 : https://doozi0316.tistory.com/entry/1%EC%A3%BC%EC%B0%A8-JVM%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EB%A9%B0-%EC%9E%90%EB%B0%94-%EC%BD%94%EB%93%9C%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B8%EA%B0%80

